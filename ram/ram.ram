main:
    stdfs open >> ./ram/test.txt
    split string >> "\n"
    var stack int vec >> [0]
    var i int >> 0
    jmp program_loop:

program_loop:
    vec str len
    ram var i
    cmp
    jne program_router:

program_router:
    // send command to cmd vec
    var cmd str vec >> [nil]
    move vec var cmd vec str
    var cmd str vec string >> [var i]
    // call lexer + parser
    jmp main_router:
    // increment the loop
    ram 1
    ram var i
    add
    ram var i prev
    jmp program_loop:

main_router:
    split string >> " "
    vec str >> [0]
    ram lxstring >> ram
    // compare for "ram"
    str cmp
    je ram:
    ram lxstring >> pop
    // compare for "pop"
    str cmp
    je pop:
    ram lxstring >> print
    // compare for print
    str cmp
    je print:
    ram lxstring >> add
    // compare for "add"
    str cmp
    je add:
    ram lxstring >> sub
    // compare for "sub"
    str cmp
    je sub:
    ram lxstring >> mul
    // compare for "mul"
    str cmp
    je mul:
    ram lxstring >> div
    // compare for "div"
    str cmp
    je div:

ram:
    vec str >> [1]
    parse int lx string
    var stack int vec push >> lx

pop:
    move vec vec int stack
    vec int pop
    move vec var stack vec int

print:
    var stack int vec len
    ram 1
    sub
    ram lx prev
    // store the last item of stack in string
    var stack int vec rv >> [lx]
    print rv

add:
    var stack int vec len
    ram 1
    sub
    // emits -1 idx
    ram lx prev
    var add_num_1 int >> 0
    var stack int vec var add_num_1 >> [lx]
    pop
    pop
    ram 2
    sub
    // emits -2 idx
    ram lx prev
    var add_num_2 int >> 0
    var stack int vec var add_num_2 >> [lx]
    ram var add_num_1
    ram var add_num_2
    add
    ram lx prev
    var stack int vec push >> lx

sub: 
    var stack int vec len
    ram 1
    sub
    // emits -1 idx
    ram lx prev
    var sub_num_1 int >> 0
    var stack int vec var sub_num_1 >> [lx]
    pop
    pop
    ram 2
    sub
    // emits -2 idx
    ram lx prev
    var sub_num_2 int >> 0
    var stack int vec var sub_num_2 >> [lx]
    ram var sub_num_2
    ram var sub_num_1
    sub
    ram lx prev
    var stack int vec push >> lx

mul:
    var stack int vec len
    ram 1
    sub
    // emits -1 idx
    ram lx prev
    var mul_num_1 int >> 0
    var stack int vec var mul_num_1 >> [lx]
    pop
    pop
    ram 2
    sub
    // emits -2 idx
    ram lx prev
    var mul_num_2 int >> 0
    var stack int vec var mul_num_2 >> [lx]
    ram var mul_num_1
    ram var mul_num_2
    mul
    ram lx prev
    var stack int vec push >> lx

div: 
    var stack int vec len
    ram 1
    sub
    // emits -1 idx
    ram lx prev
    var div_num_1 int >> 0
    var stack int vec var div_num_1 >> [lx]
    pop
    pop
    ram 2
    sub
    // emits -2 idx
    ram lx prev
    var div_num_2 int >> 0
    var stack int vec var div_num_2 >> [lx]
    ram var div_num_2
    ram var div_num_1
    div
    ram lx prev
    var stack int vec push >> lx